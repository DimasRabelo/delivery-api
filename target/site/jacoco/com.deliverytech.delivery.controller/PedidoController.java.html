<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pt"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PedidoController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">delivery-api</a> &gt; <a href="index.source.html" class="el_package">com.deliverytech.delivery.controller</a> &gt; <span class="el_source">PedidoController.java</span></div><h1>PedidoController.java</h1><pre class="source lang-java linenums">package com.deliverytech.delivery.controller;

import com.deliverytech.delivery.dto.*;
import com.deliverytech.delivery.dto.response.*;
import com.deliverytech.delivery.enums.StatusPedido;
import com.deliverytech.delivery.service.PedidoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Min;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

/**
 * Controller responsável por todas as operações de gerenciamento de Pedidos.
 *
 * Expõe endpoints para criação, consulta, atualização de status e cancelamento
 * de pedidos, com regras de segurança granulares baseadas na role do usuário
 * (CLIENTE, RESTAURANTE, ADMIN) e na propriedade do pedido.
 */
@RestController
@RequestMapping(&quot;/api/pedidos&quot;)
@CrossOrigin(origins = &quot;*&quot;)
@Validated
@Tag(name = &quot;5. Pedidos&quot;, description = &quot;Gerenciamento de pedidos e operações relacionadas&quot;)
@SecurityRequirement(name = &quot;bearerAuth&quot;) // Aplica o cadeado a todos os endpoints
<span class="fc" id="L43">public class PedidoController {</span>

    @Autowired
    private PedidoService pedidoService;

    /**
     * Cria um novo pedido no sistema.
     * Acesso restrito a usuários com a role 'CLIENTE'.
     *
     * @param dto DTO contendo os itens, clienteId e restauranteId do pedido.
     * @return ResponseEntity 201 (Created) com os dados do pedido criado.
     *
     * @implNote A lógica de segurança no {@link PedidoService#criarPedido(PedidoDTO)}
     * deve garantir que o 'clienteId' no DTO seja ignorado e substituído
     * pelo ID do usuário autenticado ({@code principal.id}), para evitar que um
     * cliente crie um pedido em nome de outro.
     */
    @PostMapping
    @PreAuthorize(&quot;hasRole('CLIENTE')&quot;)
    @Operation(summary = &quot;Criar pedido (CLIENTE)&quot;,
               description = &quot;Cria um novo pedido no sistema. Requer role 'CLIENTE'.&quot;)
    @ApiResponses({
            @ApiResponse(responseCode = &quot;201&quot;, description = &quot;Pedido criado com sucesso&quot;,
                         content = @Content(schema = @Schema(implementation = PedidoResponseDTO.class))),
            @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Dados inválidos (ex: itens vazios)&quot;),
            @ApiResponse(responseCode = &quot;401&quot;, description = &quot;Token ausente ou inválido&quot;),
            @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado (não é CLIENTE)&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Cliente ou restaurante não encontrado&quot;),
            @ApiResponse(responseCode = &quot;409&quot;, description = &quot;Produto indisponível ou restaurante fechado&quot;)
    })
    public ResponseEntity&lt;ApiResponseWrapper&lt;PedidoResponseDTO&gt;&gt; criarPedido(
            @Parameter(description = &quot;Informações do pedido a ser criado&quot;, required = true)
            @Valid @RequestBody PedidoDTO dto) {

<span class="nc" id="L77">        PedidoResponseDTO pedido = pedidoService.criarPedido(dto);</span>
<span class="nc" id="L78">        ApiResponseWrapper&lt;PedidoResponseDTO&gt; response =</span>
                new ApiResponseWrapper&lt;&gt;(true, pedido, &quot;Pedido criado com sucesso&quot;);
<span class="nc" id="L80">        return ResponseEntity.status(HttpStatus.CREATED).body(response);</span>
    }

    /**
     * Busca um pedido específico pelo seu ID.
     * Acesso permitido para 'ADMIN' ou para usuários (CLIENTE/RESTAURANTE)
     * que tenham acesso ao pedido (verificado por {@code @pedidoService.canAccess}).
     *
     * @param id O ID (Long) do pedido.
     * @return ResponseEntity 200 (OK) com os dados do pedido.
     */
    @GetMapping(&quot;/{id}&quot;)
    @PreAuthorize(&quot;hasRole('ADMIN') or @pedidoService.canAccess(#id)&quot;)
    @Operation(summary = &quot;Buscar pedido por ID (ADMIN ou Dono/Restaurante)&quot;,
               description = &quot;Recupera um pedido específico. Requer ADMIN ou ser o cliente/restaurante do pedido.&quot;)
    @ApiResponses({
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Pedido encontrado&quot;,
                         content = @Content(schema = @Schema(implementation = PedidoResponseDTO.class))),
            @ApiResponse(responseCode = &quot;401&quot;, description = &quot;Token ausente ou inválido&quot;),
            @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Pedido não encontrado&quot;)
    })
    public ResponseEntity&lt;ApiResponseWrapper&lt;PedidoResponseDTO&gt;&gt; buscarPorId(
            @Parameter(description = &quot;ID do pedido que você deseja buscar&quot;, required = true, example = &quot;1&quot;)
            @PathVariable @Min(value = 1, message = &quot;O ID do pedido deve ser maior que zero&quot;) Long id) {

<span class="nc" id="L106">        PedidoResponseDTO pedido = pedidoService.buscarPedidoPorId(id);</span>
<span class="nc" id="L107">        ApiResponseWrapper&lt;PedidoResponseDTO&gt; response =</span>
                new ApiResponseWrapper&lt;&gt;(true, pedido, &quot;Pedido encontrado&quot;);
<span class="nc" id="L109">        return ResponseEntity.ok(response);</span>
    }

    /**
     * Lista todos os pedidos do sistema de forma paginada.
     * Acesso restrito a usuários com a role 'ADMIN'.
     *
     * @param status     (Opcional) Filtra pedidos pelo status.
     * @param dataInicio (Opcional) Filtra pedidos a partir desta data.
     * @param dataFim    (Opcional) Filtra pedidos até esta data.
     * @param pageable   Objeto de paginação.
     * @return ResponseEntity 200 (OK) com a página de pedidos.
     */
    @GetMapping
    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)
    @Operation(summary = &quot;Listar todos os pedidos (ADMIN)&quot;,
               description = &quot;Lista todos os pedidos com filtros e paginação. Requer role 'ADMIN'.&quot;)
    @ApiResponses({
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Pedidos listados com sucesso&quot;),
            @ApiResponse(responseCode = &quot;401&quot;, description = &quot;Token ausente ou inválido&quot;),
            @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado (não é ADMIN)&quot;)
    })
    public ResponseEntity&lt;PagedResponseWrapper&lt;PedidoResponseDTO&gt;&gt; listar(
            @Parameter(description = &quot;Filtra pedidos pelo status&quot;, example = &quot;EM_PREPARO&quot;)
            @RequestParam(required = false) StatusPedido status,

            @Parameter(description = &quot;Data inicial do filtro (YYYY-MM-DD)&quot;, example = &quot;2025-10-01&quot;)
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataInicio,

            @Parameter(description = &quot;Data final do filtro (YYYY-MM-DD)&quot;, example = &quot;2025-10-23&quot;)
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataFim,

            @Parameter(description = &quot;Informações de paginação&quot;) Pageable pageable) {

<span class="nc" id="L143">        Page&lt;PedidoResponseDTO&gt; pedidos = pedidoService.listarPedidos(status, dataInicio, dataFim, pageable);</span>
<span class="nc" id="L144">        PagedResponseWrapper&lt;PedidoResponseDTO&gt; response = new PagedResponseWrapper&lt;&gt;(pedidos);</span>
<span class="nc" id="L145">        return ResponseEntity.ok(response);</span>
    }

    /**
     * Lista os pedidos do CLIENTE autenticado, de forma paginada.
     * Acesso restrito ao próprio cliente.
     *
     * @param pageable Objeto de paginação.
     * @return ResponseEntity 200 (OK) com a página de pedidos do cliente.
     */
    @GetMapping(&quot;/meus&quot;)
    @PreAuthorize(&quot;hasRole('CLIENTE')&quot;)
    @Operation(summary = &quot;Listar meus pedidos (CLIENTE)&quot;,
               description = &quot;Lista os pedidos do cliente autenticado com paginação. Requer role 'CLIENTE'.&quot;)
    @ApiResponses({
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Pedidos listados com sucesso&quot;),
            @ApiResponse(responseCode = &quot;401&quot;, description = &quot;Token ausente ou inválido&quot;),
            @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado (não é CLIENTE)&quot;)
    })
    public ResponseEntity&lt;PagedResponseWrapper&lt;PedidoResponseDTO&gt;&gt; listarMeusPedidos(
            @Parameter(description = &quot;Informações de paginação&quot;) Pageable pageable) {

<span class="nc" id="L167">        Page&lt;PedidoResponseDTO&gt; pedidos = pedidoService.listarMeusPedidos(pageable);</span>
        
<span class="nc" id="L169">        PagedResponseWrapper&lt;PedidoResponseDTO&gt; response = new PagedResponseWrapper&lt;&gt;(pedidos);</span>
<span class="nc" id="L170">        return ResponseEntity.ok(response);</span>
    }

    /**
     * Atualiza o status de um pedido (ex: PENDENTE -&gt; EM_PREPARO).
     * Acesso permitido para 'ADMIN' ou para usuários (CLIENTE/RESTAURANTE)
     * que tenham acesso ao pedido.
     *
     * @param id        O ID do pedido a ser atualizado.
     * @param statusDTO DTO contendo o novo status (String).
     * @return ResponseEntity 200 (OK) com os dados do pedido atualizado.
     *
     * @implNote A lógica de *quais* transições de status são permitidas para
     * *qual* usuário (CLIENTE vs RESTAURANTE) deve ser implementada
     * dentro do {@link PedidoService#atualizarStatusPedido(Long, StatusPedido)}.
     */
    @PatchMapping(&quot;/{id}/status&quot;)
    @PreAuthorize(&quot;hasRole('ADMIN') or @pedidoService.canAccess(#id)&quot;)
    @Operation(summary = &quot;Atualizar status do pedido (ADMIN ou Dono/Restaurante)&quot;,
               description = &quot;Atualiza o status de um pedido (ex: EM_PREPARO, ENTREGUE, CANCELADO).&quot;)
    @ApiResponses({
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Status atualizado com sucesso&quot;),
            @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Status inválido ou transição não permitida&quot;),
            @ApiResponse(responseCode = &quot;401&quot;, description = &quot;Token ausente ou inválido&quot;),
            @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Pedido não encontrado&quot;)
    })
    public ResponseEntity&lt;ApiResponseWrapper&lt;PedidoResponseDTO&gt;&gt; atualizarStatus(
            @Parameter(description = &quot;ID do pedido que será atualizado&quot;, required = true, example = &quot;1&quot;)
            @PathVariable @Min(value = 1, message = &quot;O ID do pedido deve ser maior que zero&quot;) Long id,

            @Parameter(description = &quot;Novo status do pedido&quot;, required = true,
                       content = @Content(schema = @Schema(implementation = StatusPedidoDTO.class)))
            @Valid @RequestBody StatusPedidoDTO statusDTO) {

        // Validação manual para converter a String do DTO para o Enum
        StatusPedido novoStatus;
        try {
<span class="nc" id="L208">            novoStatus = StatusPedido.valueOf(statusDTO.getStatus().toUpperCase());</span>
<span class="nc" id="L209">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L210">            ApiResponseWrapper&lt;PedidoResponseDTO&gt; errorResponse =</span>
<span class="nc" id="L211">                    new ApiResponseWrapper&lt;&gt;(false, null, &quot;Status inválido: &quot; + statusDTO.getStatus());</span>
<span class="nc" id="L212">            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);</span>
<span class="nc" id="L213">        }</span>

<span class="nc" id="L215">        PedidoResponseDTO pedido = pedidoService.atualizarStatusPedido(id, novoStatus);</span>
<span class="nc" id="L216">        ApiResponseWrapper&lt;PedidoResponseDTO&gt; response =</span>
                new ApiResponseWrapper&lt;&gt;(true, pedido, &quot;Status atualizado com sucesso&quot;);
<span class="nc" id="L218">        return ResponseEntity.ok(response);</span>
    }

    /**
     * Cancela um pedido.
     * Acesso permitido para 'ADMIN' ou para usuários (CLIENTE/RESTAURANTE)
     * que tenham acesso ao pedido.
     *
     * @param id O ID do pedido a ser cancelado.
     * @return ResponseEntity 204 (No Content).
     *
     * @implNote A lógica de negócio no {@link PedidoService#cancelarPedido(Long)}
     * deve verificar se o pedido *ainda pode* ser cancelado
     * (ex: se o status ainda for 'PENDENTE' ou 'EM_PREPARO').
     */
    @DeleteMapping(&quot;/{id}&quot;)
    @PreAuthorize(&quot;hasRole('ADMIN') or @pedidoService.canAccess(#id)&quot;)
    @Operation(summary = &quot;Cancelar pedido (ADMIN ou Dono/Restaurante)&quot;,
               description = &quot;Cancela um pedido. Requer ADMIN ou ser o cliente/restaurante do pedido.&quot;)
    @ApiResponses({
            @ApiResponse(responseCode = &quot;204&quot;, description = &quot;Pedido cancelado com sucesso&quot;),
            @ApiResponse(responseCode = &quot;401&quot;, description = &quot;Token ausente ou inválido&quot;),
            @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Pedido não encontrado&quot;),
            @ApiResponse(responseCode = &quot;409&quot;, description = &quot;Não é mais possível cancelar este pedido&quot;)
    })
    public ResponseEntity&lt;Void&gt; cancelarPedido(
            @Parameter(description = &quot;ID do pedido que será cancelado&quot;, required = true, example = &quot;1&quot;)
            @PathVariable @Min(value = 1, message = &quot;O ID do pedido deve ser maior que zero&quot;) Long id) {

<span class="nc" id="L248">        pedidoService.cancelarPedido(id);</span>
<span class="nc" id="L249">        return ResponseEntity.noContent().build();</span>
    }

    /**
     * Busca o histórico de pedidos de um cliente específico.
     * Acesso permitido para 'ADMIN' ou para o próprio 'CLIENTE'.
     *
     * @param clienteId O ID do cliente.
     * @return ResponseEntity 200 (OK) com a lista de pedidos do cliente.
     */
    @GetMapping(&quot;/cliente/{clienteId}&quot;)
    @PreAuthorize(&quot;hasRole('ADMIN') or (hasRole('CLIENTE') and #clienteId == principal.id)&quot;)
    @Operation(summary = &quot;Histórico de pedidos do cliente (ADMIN ou Dono)&quot;,
               description = &quot;Retorna todos os pedidos de um cliente. Requer ADMIN ou ser o próprio cliente.&quot;)
    @ApiResponses({
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Histórico recuperado com sucesso&quot;),
            @ApiResponse(responseCode = &quot;401&quot;, description = &quot;Token ausente ou inválido&quot;),
            @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado (não é ADMIN ou o dono da conta)&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Cliente não encontrado&quot;)
    })
    public ResponseEntity&lt;ApiResponseWrapper&lt;List&lt;PedidoResponseDTO&gt;&gt;&gt; buscarPorCliente(
            @Parameter(description = &quot;ID do cliente para consulta&quot;, required = true, example = &quot;1&quot;)
            @PathVariable @Min(value = 1, message = &quot;O ID do cliente deve ser maior que zero&quot;) Long clienteId) {

<span class="nc" id="L273">        List&lt;PedidoResponseDTO&gt; pedidos = pedidoService.buscarPedidosPorCliente(clienteId);</span>
<span class="nc" id="L274">        ApiResponseWrapper&lt;List&lt;PedidoResponseDTO&gt;&gt; response =</span>
                new ApiResponseWrapper&lt;&gt;(true, pedidos, &quot;Histórico recuperado com sucesso&quot;);
<span class="nc" id="L276">        return ResponseEntity.ok(response);</span>
    }

    /**
     * Busca todos os pedidos de um restaurante específico.
     * Acesso permitido para 'ADMIN' ou para o 'RESTAURANTE' proprietário.
     *
     * @param restauranteId O ID do restaurante.
     * @param status        (Opcional) Filtra os pedidos do restaurante por status.
     * @return ResponseEntity 200 (OK) com a lista de pedidos do restaurante.
     */
    @GetMapping(&quot;/restaurante/{restauranteId}&quot;)
    @PreAuthorize(&quot;hasRole('ADMIN') or (hasRole('RESTAURANTE') and #restauranteId == principal.restauranteId)&quot;)
    @Operation(summary = &quot;Pedidos por restaurante (ADMIN ou Dono)&quot;,
               description = &quot;Lista todos os pedidos de um restaurante. Requer ADMIN ou ser o dono do restaurante.&quot;)
    @ApiResponses({
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Pedidos recuperados com sucesso&quot;),
            @ApiResponse(responseCode = &quot;401&quot;, description = &quot;Token ausente ou inválido&quot;),
            @ApiResponse(responseCode = &quot;403&quot;, description = &quot;Acesso negado (não é ADMIN ou o dono do restaurante)&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Restaurante não encontrado&quot;)
    })
    public ResponseEntity&lt;ApiResponseWrapper&lt;List&lt;PedidoResponseDTO&gt;&gt;&gt; buscarPorRestaurante(
            @Parameter(description = &quot;ID do restaurante para consulta&quot;, required = true, example = &quot;1&quot;)
            @PathVariable @Min(value = 1, message = &quot;O ID do restaurante deve ser maior que zero&quot;) Long restauranteId,

            @Parameter(description = &quot;Filtra pedidos pelo status&quot;, example = &quot;ENTREGUE&quot;)
            @RequestParam(required = false) StatusPedido status) {

<span class="nc" id="L304">        List&lt;PedidoResponseDTO&gt; pedidos = pedidoService.buscarPedidosPorRestaurante(restauranteId, status);</span>
<span class="nc" id="L305">        ApiResponseWrapper&lt;List&lt;PedidoResponseDTO&gt;&gt; response =</span>
                new ApiResponseWrapper&lt;&gt;(true, pedidos, &quot;Pedidos recuperados com sucesso&quot;);
<span class="nc" id="L307">        return ResponseEntity.ok(response);</span>
    }

    /**
     * Calcula o total de um pedido (subtotal, taxa de entrega, total)
     * sem salvá-lo no banco de dados. Endpoint público.
     *
     * @param dto DTO contendo os itens e o CEP de entrega para o cálculo.
     * @return ResponseEntity 200 (OK) com os valores calculados.
     */
    @PostMapping(&quot;/calcular&quot;)
    @Operation(summary = &quot;Calcular total do pedido (Público)&quot;,
               description = &quot;Calcula o total de um pedido (itens + taxa) sem salvar no banco.&quot;)
    @ApiResponses({
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Total calculado com sucesso&quot;,
                         content = @Content(schema = @Schema(implementation = CalculoPedidoResponseDTO.class))),
            @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Dados inválidos (ex: CEP)&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Restaurante ou produto não encontrado&quot;)
    })
    @SecurityRequirement(name = &quot;bearerAuth&quot;, scopes = {}) // Remove o cadeado apenas para este endpoint
    public ResponseEntity&lt;ApiResponseWrapper&lt;CalculoPedidoResponseDTO&gt;&gt; calcularTotal(
            @Parameter(description = &quot;Itens do pedido para cálculo&quot;, required = true)
            @Valid @RequestBody CalculoPedidoDTO dto) {

<span class="nc" id="L331">        CalculoPedidoResponseDTO calculo = pedidoService.calcularTotalPedido(dto);</span>
<span class="nc" id="L332">        ApiResponseWrapper&lt;CalculoPedidoResponseDTO&gt; response =</span>
                new ApiResponseWrapper&lt;&gt;(true, calculo, &quot;Total calculado com sucesso&quot;);
<span class="nc" id="L334">        return ResponseEntity.ok(response);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>